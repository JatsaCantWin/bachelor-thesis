\chapter{Database Management Systems}
\label{ch:background}
\par There are numerous distinct database solutions available on the market already, each boasting its unique characteristics and design philosophy. These DBMSs (Database Management Systems) can be classified into these two categories:
\begin{description}
  \item[SQL databases] based on a relational model, their engines implement some dialect of the SQL language.
  \item[NoSQL databases] a term used to describe various other database solutions that rely on documents, graphs, key-value pairs, or other structures to organize their data, rather than the relational model endorsed by SQL\citep{SQLvNOSQL}.
\end{description}

\par Generally, NoSQL DBMSs compromise data consistency in favor of data availability and speed of data processing.

\section{SQL}
\label{sec:background:first_section}
\par Structured Query Language (SQL) is a collection of various languages used to define the interaction between the user and the database engine. Initially developed in the 70s at IBM, it gained popularity and dominated the Relation Database Management System market\citep{SQLHandbook}.
\par The relational database organization model used in SQL organizes data into two-dimensional array structures called tables. Each table is a series of row-like records of simple data types such as an integer, a string of text, or a date, although holding binary data of any kind is possible. These records must all contain the same kind of data, arranged in the same order - the word columns or fields is often used to describe single pieces of data stored in this order. The same data in different tables may be related and thus create links between these tables, called relations.
\par As was mentioned earlier, the Structured Query Language is composed of four different languages, each describing different kinds of interactions possible with the Database engine\citep{KreibchSQLite}:
\begin{description}
  \item[SQL Data Manipulation Language] is used to create and modify data.
  \item[SQL Data Definition Language] is used to create and modify structures in which data is stored.
  \item[SQL Data Control Language] is used to grant permission to access and modify data inside the database system.
  \item[SQL Data Query Language] is used to read data from the system in various ways.
\end{description}
\par These languages combined can create complex queries that can store and access data in various unique ways, satisfying the need of even the most complex database systems.
\par Another important mechanism introduced in SQL is the so-called "transaction." It is defined as a set of database queries, executed one after another, whose results are only implemented if all of these queries execute successfully \citep{SQLHandbook}. These transactions should obey the principles of ACID - Atomicity, Consistency, Isolation, Durability\citep{ACID}.
\begin{description}
  \item[Atomicity] means that if one of the queries that make up a transaction fails, none of the changes implemented by the rest of the transaction takes place.
  \item[Consistency] ensures that the database will remain valid and operational whether or not the transaction succeeds.
  \item[Isolation] of transactions requires the data of the in-between states of a database transaction to be completely invisible and unavailable to other transactions.
  \item[Durability] in terms of transactions means that after a transaction is successfully executed, its effect will stay in the database, even if subsequent operations fail.
\end{description}
\par Implementation of these properties ensures stability and Consistency, often required in many database instances. The payoff, however, is the increased amount of computations needed to perform basic operations since every operation needs certain checks and data analyses to conform to these principles.

\subsection{SQLite}
\label{subsec:background:first_seciton:first_subsection}
\par In comparison with the rest of SQL-based solutions, SQLite is unique in that it does not come with an engine that is constantly running and waiting for users to connect and issue queries. Rather than that, SQLite stores its data in a simple file stored on a hard drive that can then be accessed by various SQLite-compatible applications that can open, read and modify the file according to the SQL standard and then close the file\citep{OwensSQLite}.
\par Because of its quirks, SQLite lacks in the speed of reading and writing data. It also allows only one application to access and modify the contents of its database. Its strength, however, lies in its lightness, simplicity, and low resource intensity. It is an excellent data storage solution for simple apps, especially on mobile devices, since they can rarely afford an online-only database or constant access to a database hosted on a remote network. It can also find great use in databases that act as buffers or temporary storage for other, larger systems\citep{OwensSQLite}.

\subsection{PostgresSQL}
\label{subsec:background:first_section:second_subsection}
\par PostgresSQL is one of the most popular open-source implementations of the SQL paradigm\citep{worsleyPostgresSQL}. It also includes its own programming language, PL/pgSQL, used to create advanced procedures and to include external scripts from other languages usually not associated with relational databases, such as Perl or Python. 
\par PostgresSQL expands on the standard relational model of the SQL language by introducing the concept of objects, inheritance, and arrays, known from conventional programming languages. The user can now store multiple values in a single column, create child-parent relationships between tables and even create complex programs that SQL statements can invoke. In this so-called object-relational model, tables are sometimes called objects, and columns are called properties of said objects\citep{ACID}.

\section{NoSQL}
\label{sec:background:second_section}
\par As relational databases slowly developed to dominate the DBMS market, their flaws have become more apparent. They are relatively easy to use and maintain, and the various languages that comprise the SQL standard allow the execution of as simple or as complex operations as the user needs. 
\par The transaction mechanism mentioned above and its ACIDidty takes care of the heavy lifting required to ensure the stability of extensive database systems. This same ACIDity takes its toll on the DBMS's performance since every operation must complete ensuring it complies with every ACID principle. This problem becomes significantly exacerbated when dealing with distributed database implementations, present concurrently on multiple systems\citep{HewittCassandra}. A special protocol called \textbf{"two-phase commit protocol"} was invented to deal with this problem. When using this protocol, a special coordinator mediates between the user and every system that makes up the database. It first sends the query to every DBMS participating in the distributed network and waits until every one of these participants finishes executing the transaction until the very last step, where the transaction is "committed" to the database (hence the name). If every single one of these members executes the transaction successfully, it sends an all-clear signal to every subsystem and allows them to finalize the transaction. If anything goes wrong in either system, the coordinator ensures that the transaction is canceled everywhere\citep{TwoPhaseCommit}. Unfortunately, since this 2PC protocol locks every resource the transaction uses and extends the time needed to complete an operation, it is only applicable in small operations that can complete very quickly without compromising the entire system's responsiveness. Since that is not always the case, it may not be beneficial to want to ensure the ACIDity of every single operation\citep{HewittCassandra}.
\par Another problem with RDBMS is the traditional structure of SQL-based database schemas. They require the user to store data in rigid table structures, often requiring separate tables representing data relationships such as one-to-many, many-to-many, or one-to-one. This model makes complex queries even harder to compose and interpret by a human and makes complex database schemas especially difficult to read. Also, in many cases, it is challenging to design a database schema that accurately represents the necessary data while complying with the RDBMS model\citep{HewittCassandra}.
\par In summary, while excellent in many general cases, certain DBMS implementations may require going beyond the constraints of the SQL model. These SQL-defying database solutions began to be called NoSQL or "Not only SQL"\citep{SQLvNOSQL}.

\subsection{Cassandra}
\label{subsec:background:second_section:first_subsection}
\par Cassandra is a DBMS designed with scalability and ease of access. Because of its exceptional ability to hold a large amount of data and process lots of writes, it is often used in real-time applications, such as financial software or, more interestingly, for our purposes, hardware sensors\citep{CassandraUseCase}. 
\par Cassandra is designed to work on multiple systems or \textbf{"nodes"}, working in large groups called \textbf{"clusters"}. These clusters are also sometimes called rings since they connect each node they consist of into ring-like structures. Every node contains its copy of the data and can interact with users. A peer-to-peer protocol allows nodes to communicate and synchronize their data. This system also has a unique advantage in terms of data durability - a single node failure will not disrupt the operation of the entire database. Neither will it compromise the data gathered by the failed node since it most likely would have already been sent to another functioning node\citep{HewittCassandra}.
\par Cassandra favors data availability over data consistency. Generally, in different DBMSs, we can describe data consistency in three categories:
\begin{description}
  \item [Strict Consistency], is usually found in single-threaded systems running a single-node database. In this system, requests are always processed sequentially, so reading outdated data is impossible.
  \item [Casual Consistency], tries to determine how operations relate to one another and only executes operations if their related proceeding operations have already been processed.
  \item [Weak Consistency], sometimes called eventual Consistency, is the type of Consistency Cassandra favors. It means that data can be read, even if a yet not processed operation may have overwritten it. The data will eventually be propagated to be consistent throughout the database, but that may take some time. 
\end{description}
\par Cassandra uses the last, seemingly worst type of Consistency checking since the first one is antithetical to the design philosophy of a clustered database such as Cassandra, and the second approach would hamper data availability, which takes precedence over Consistency in Cassandra. Furthermore, it is possible to select a level of Consistency by tuning the number of nodes that the data managed to propagate to before accepting the operation as completed. \citep{HewittCassandra}.
\par Cassandra offers a lot more relaxed approach to designing data models. SQL-like data rows are stored in so-called \textbf{"column families"}, roughly equivalent to SQL tables. A single row in a column family, however, can store as many or as few columns as necessary, unlike SQL Tables, which have to have the same amount of columns per row in every single row, thus creating a rectangle-like structure. A single Cassandra column also can become a super column and carry multiple other columns of any type inside itself. This feature eliminates the need to create relational tables, known from Relational DBMS\citep{HewittCassandra}.
\par Cassandra has its own query language, the CQL (Cassandra Query Langauge). It is very similar to SQL, although it does not include any elements related to transactions or constraints since those do not feature in Cassandra. \citep{CQL}

\subsection{MongoDB}
\label{subsec:background:second_section:second_subsection}
\par MongoDB is another good example of the NoSQL database design paradigm, moving away from the relational database model in favor of a document-oriented one \citep{mongoDB}. Instead of rows, MongoDB introduces documents - loose collections of data representative of how modern object-oriented programmers organize their data. MongoDB databases are much more flexible and easier to add data to and experiment with, thanks to MongoDB not requiring a fixed schema for all documents inside one data collection.
\par MongoDB is also excellent for large databases that often have to be spread across several machines to be scaleable - the MongoDB engine automatically handles balancing documents across various machines in a single cluster\citep{mongoDB}. 
\par Documents used by MongoDB are ordered sets of key-value pairs, similar to dictionaries or maps, known from conventional programming languages. These documents are represented using the JSON standard, making them intuitive to experienced programmers. These documents are grouped in collections, analogous to SQL's tables\citep{mongoDB}. Unlike SQL tables, this system is much more flexible, allowing one to implement all data relationships without creating special collections. This system does require more logic to be implemented on the application side, though, since it will not check the Consistency of the schema like SQL does\citep{MongovMySQL}.
\par This DBMS's interface is a fully featured javascript interpreter, giving the user the flexibility of the entire JS language with its standard libraries. Queries, inserts, deletions, and modifications to the data can be done via MongoDB's javascript-compatible API\citep{mongoDB}.
\par MongoDB's write system is asynchronous, meaning an operation that modifies or creates data inside a database does not need to be completed before issuing another operation. While this improves database performance, it significantly reduces reliability and Consistency\citep{MongovMySQL}.
\par MongoDB features a unique query language, the MQL (MongoDB Query Language). The JSON used to represent documents is also used to perform specific queries, create, update, read and delete data, and more complex queries using the aggregate mechanism. 

\subsection{Prometheus}
\label{subsec:background:second_section:thrid_subsection}
\par Sensors and other IoT applications can be challenging for traditional RDBMSs. These systems usually cannot handle large amounts of increasingly growing data in monitoring systems. A series of hacks can be used on RDBMSs to optimize them for these conditions. However, these measures may not be enough for long\citep{timeseries}. Since these monitoring systems usually have some things in common: a timestamp attached to all data, lots of writes being issued periodically, and most of the queries being very simple, a new type of a NoSQL database has been invented - a time series database, tailored explicitly around these constraints. 
\par One famous implementation of this paradigm is a TSDBMS called Prometheus. It uses a unique pull-based data acquisition model, which periodically asks its clients to provide data rather than wait for them to provide it themselves. This model can prove beneficial since it is easier to monitor the stability of communication with each database client this way and quickly start monitoring additional targets. \citep{prometheusFAQ}. If one prefers the push-based model, this constraint can be overcome by using a second module called a Pushgateway, which accepts data from clients whenever they decide to push it and then provides it to Prometheus using the pull-based model. \citep{prometheusPushing/}
Communication with Prometheus is facilitated over the HTTP protocol. The Prometheus database provides easy access to users or external APIs to query data or receive alerts - special notifications triggered when a specific condition is met. \citep{prometheusFAQ}
\par Prometheus provides a rich query language of its own, the PromQL (Prometheus Query Language), which is much different from its relational equivalent. It can easily retrieve specific data and excels in analytics, featuring many functions useful in monitoring and processing gathered data. PromQL can also be used to set up alters, which, similar to triggers, execute every time data is gathered and can be used to detect specific patterns or undesirable values among the data. \citep{PromQL}
